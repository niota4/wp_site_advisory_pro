<?php
/**
 * WSA Pro Vulnerability Scanner Class
 *
 * Advanced vulnerability scanning with WPScan integration
 *
 * @package WSA_Pro
 */

if (!defined('ABSPATH')) {
    exit;
}

class WSA_Pro_Vulnerability_Scanner {

    /**
     * Single instance of the class
     */
    private static $instance = null;

    /**
     * WPScan API endpoint
     */
    private $wpscan_api_url = 'https://wpscan.com/api/v3/';

    /**
     * Constructor
     */
    private function __construct() {
        $this->init_hooks();
    }

    /**
     * Get single instance of the class
     */
    public static function get_instance() {
        if (null === self::$instance) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Initialize hooks
     */
    private function init_hooks() {
        // Enhance plugin scanning with vulnerability checks
        add_filter('wsa_plugin_scan_results', array($this, 'add_vulnerability_data'), 10, 2);
        add_action('wp_ajax_wsa_pro_vulnerability_scan', array($this, 'ajax_vulnerability_scan'));
    }

    /**
     * Perform comprehensive vulnerability scan
     */
    public function scan($plugins = array()) {
        // Verify license
        if (!wsa_pro_is_license_active()) {
            return new WP_Error('license_required', __('Vulnerability scanning requires a valid Pro license.', 'wp-site-advisory-pro'));
        }

        if (empty($plugins)) {
            $plugins = get_plugins();
        }

        $results = array(
            'scanned_plugins' => 0,
            'vulnerabilities_found' => 0,
            'critical_vulnerabilities' => 0,
            'high_vulnerabilities' => 0,
            'medium_vulnerabilities' => 0,
            'low_vulnerabilities' => 0,
            'plugin_results' => array(),
            'scan_timestamp' => current_time('mysql')
        );

        foreach ($plugins as $plugin_path => $plugin_data) {
            // Skip if plugin is not active
            if (!is_plugin_active($plugin_path)) {
                continue;
            }

            $results['scanned_plugins']++;
            
            $plugin_slug = dirname($plugin_path);
            $plugin_version = $plugin_data['Version'];

            // Get vulnerability data for this plugin
            $vulnerabilities = $this->get_plugin_vulnerabilities($plugin_slug, $plugin_version);

            if (!empty($vulnerabilities)) {
                $plugin_result = array(
                    'name' => $plugin_data['Name'],
                    'slug' => $plugin_slug,
                    'version' => $plugin_version,
                    'vulnerabilities' => $vulnerabilities,
                    'vulnerability_count' => count($vulnerabilities),
                    'highest_severity' => $this->get_highest_severity($vulnerabilities)
                );

                $results['plugin_results'][] = $plugin_result;
                $results['vulnerabilities_found'] += count($vulnerabilities);

                // Count by severity
                foreach ($vulnerabilities as $vuln) {
                    switch (strtolower($vuln['severity'])) {
                        case 'critical':
                            $results['critical_vulnerabilities']++;
                            break;
                        case 'high':
                            $results['high_vulnerabilities']++;
                            break;
                        case 'medium':
                            $results['medium_vulnerabilities']++;
                            break;
                        case 'low':
                            $results['low_vulnerabilities']++;
                            break;
                    }
                }
            }
        }

        // Also scan WordPress core
        $wp_vulnerabilities = $this->get_wordpress_vulnerabilities();
        if (!empty($wp_vulnerabilities)) {
            $results['wordpress_vulnerabilities'] = $wp_vulnerabilities;
            $results['vulnerabilities_found'] += count($wp_vulnerabilities);
        }

        // Store results
        $this->store_vulnerability_results($results);

        return $results;
    }

    /**
     * Get vulnerabilities for a specific plugin
     */
    private function get_plugin_vulnerabilities($plugin_slug, $version) {
        $cache_key = "wsa_pro_vuln_{$plugin_slug}_{$version}";
        $cached_result = get_transient($cache_key);

        if (false !== $cached_result) {
            return $cached_result;
        }

        $vulnerabilities = array();

        // Try WPScan API first
        $wpscan_vulnerabilities = $this->get_wpscan_vulnerabilities($plugin_slug, $version);
        if (!empty($wpscan_vulnerabilities)) {
            $vulnerabilities = array_merge($vulnerabilities, $wpscan_vulnerabilities);
        }

        // Try WP Vulnerability Database
        $wpvulndb_vulnerabilities = $this->get_wpvulndb_vulnerabilities($plugin_slug, $version);
        if (!empty($wpvulndb_vulnerabilities)) {
            $vulnerabilities = array_merge($vulnerabilities, $wpvulndb_vulnerabilities);
        }

        // Remove duplicates
        $vulnerabilities = $this->deduplicate_vulnerabilities($vulnerabilities);

        // Cache results for 6 hours
        set_transient($cache_key, $vulnerabilities, 6 * HOUR_IN_SECONDS);

        return $vulnerabilities;
    }

    /**
     * Get vulnerabilities from WPScan API
     */
    private function get_wpscan_vulnerabilities($plugin_slug, $version) {
        $api_token = get_option('wsa_pro_wpscan_api_token', '');
        
        if (empty($api_token)) {
            return array(); // No API token configured
        }

        $url = $this->wpscan_api_url . "plugins/{$plugin_slug}";
        
        $args = array(
            'headers' => array(
                'Authorization' => 'Token token=' . $api_token,
                'User-Agent' => 'WP SiteAdvisor Pro/' . WSA_PRO_VERSION
            ),
            'timeout' => 15
        );

        $response = wp_remote_get($url, $args);

        if (is_wp_error($response)) {
            return array();
        }

        $body = wp_remote_retrieve_body($response);
        $data = json_decode($body, true);

        if (!isset($data[$plugin_slug]['vulnerabilities'])) {
            return array();
        }

        $vulnerabilities = array();

        foreach ($data[$plugin_slug]['vulnerabilities'] as $vuln) {
            // Check if current version is affected
            if ($this->version_is_vulnerable($version, $vuln)) {
                $vulnerabilities[] = array(
                    'id' => isset($vuln['id']) ? $vuln['id'] : uniqid(),
                    'title' => $vuln['title'],
                    'severity' => $this->determine_severity($vuln),
                    'type' => isset($vuln['vuln_type']) ? $vuln['vuln_type'] : 'Unknown',
                    'fixed_in' => isset($vuln['fixed_in']) ? $vuln['fixed_in'] : null,
                    'published_date' => isset($vuln['published_date']) ? $vuln['published_date'] : null,
                    'references' => isset($vuln['references']) ? $vuln['references'] : array(),
                    'source' => 'wpscan'
                );
            }
        }

        return $vulnerabilities;
    }

    /**
     * Get vulnerabilities from WP Vulnerability Database (fallback)
     */
    private function get_wpvulndb_vulnerabilities($plugin_slug, $version) {
        // Simplified vulnerability database check
        // In a real implementation, this would connect to a vulnerability database
        
        $known_vulnerabilities = $this->get_known_vulnerabilities();
        
        if (!isset($known_vulnerabilities[$plugin_slug])) {
            return array();
        }

        $vulnerabilities = array();

        foreach ($known_vulnerabilities[$plugin_slug] as $vuln) {
            if ($this->version_is_vulnerable($version, $vuln)) {
                $vulnerabilities[] = array(
                    'id' => $vuln['id'],
                    'title' => $vuln['title'],
                    'severity' => $vuln['severity'],
                    'type' => $vuln['type'],
                    'fixed_in' => $vuln['fixed_in'],
                    'published_date' => $vuln['published_date'],
                    'references' => $vuln['references'],
                    'source' => 'wpvulndb'
                );
            }
        }

        return $vulnerabilities;
    }

    /**
     * Get WordPress core vulnerabilities
     */
    private function get_wordpress_vulnerabilities() {
        $wp_version = get_bloginfo('version');
        $cache_key = "wsa_pro_wp_vuln_{$wp_version}";
        $cached_result = get_transient($cache_key);

        if (false !== $cached_result) {
            return $cached_result;
        }

        // Check WordPress core vulnerabilities
        $vulnerabilities = array();

        // WPScan WordPress core check
        $api_token = get_option('wsa_pro_wpscan_api_token', '');
        
        if (!empty($api_token)) {
            $url = $this->wpscan_api_url . "wordpresses/{$wp_version}";
            
            $args = array(
                'headers' => array(
                    'Authorization' => 'Token token=' . $api_token,
                    'User-Agent' => 'WP SiteAdvisor Pro/' . WSA_PRO_VERSION
                ),
                'timeout' => 15
            );

            $response = wp_remote_get($url, $args);

            if (!is_wp_error($response)) {
                $body = wp_remote_retrieve_body($response);
                $data = json_decode($body, true);

                if (isset($data[$wp_version]['vulnerabilities'])) {
                    foreach ($data[$wp_version]['vulnerabilities'] as $vuln) {
                        $vulnerabilities[] = array(
                            'id' => isset($vuln['id']) ? $vuln['id'] : uniqid(),
                            'title' => $vuln['title'],
                            'severity' => $this->determine_severity($vuln),
                            'type' => 'WordPress Core',
                            'fixed_in' => isset($vuln['fixed_in']) ? $vuln['fixed_in'] : null,
                            'published_date' => isset($vuln['published_date']) ? $vuln['published_date'] : null,
                            'references' => isset($vuln['references']) ? $vuln['references'] : array(),
                            'source' => 'wpscan'
                        );
                    }
                }
            }
        }

        // Cache for 12 hours
        set_transient($cache_key, $vulnerabilities, 12 * HOUR_IN_SECONDS);

        return $vulnerabilities;
    }

    /**
     * Check if version is vulnerable
     */
    private function version_is_vulnerable($current_version, $vulnerability) {
        if (!isset($vulnerability['fixed_in'])) {
            return true; // Assume vulnerable if no fix version specified
        }

        return version_compare($current_version, $vulnerability['fixed_in'], '<');
    }

    /**
     * Determine severity from vulnerability data
     */
    private function determine_severity($vulnerability) {
        if (isset($vulnerability['cvss_score'])) {
            $score = floatval($vulnerability['cvss_score']);
            if ($score >= 9.0) return 'Critical';
            if ($score >= 7.0) return 'High';
            if ($score >= 4.0) return 'Medium';
            return 'Low';
        }

        // Fallback based on vulnerability type
        if (isset($vulnerability['vuln_type'])) {
            $type = strtolower($vulnerability['vuln_type']);
            if (strpos($type, 'sql injection') !== false) return 'Critical';
            if (strpos($type, 'remote code execution') !== false) return 'Critical';
            if (strpos($type, 'privilege escalation') !== false) return 'High';
            if (strpos($type, 'cross-site scripting') !== false) return 'Medium';
        }

        return 'Medium'; // Default severity
    }

    /**
     * Get highest severity from vulnerabilities
     */
    private function get_highest_severity($vulnerabilities) {
        $severity_levels = array('Critical' => 4, 'High' => 3, 'Medium' => 2, 'Low' => 1);
        $highest = 0;
        $highest_severity = 'Low';

        foreach ($vulnerabilities as $vuln) {
            $level = isset($severity_levels[$vuln['severity']]) ? $severity_levels[$vuln['severity']] : 1;
            if ($level > $highest) {
                $highest = $level;
                $highest_severity = $vuln['severity'];
            }
        }

        return $highest_severity;
    }

    /**
     * Remove duplicate vulnerabilities
     */
    private function deduplicate_vulnerabilities($vulnerabilities) {
        $unique = array();
        $seen = array();

        foreach ($vulnerabilities as $vuln) {
            $key = $vuln['title'] . '_' . $vuln['type'];
            if (!isset($seen[$key])) {
                $unique[] = $vuln;
                $seen[$key] = true;
            }
        }

        return $unique;
    }

    /**
     * Get known vulnerabilities (simplified database)
     */
    private function get_known_vulnerabilities() {
        // This is a simplified version. In production, this would be a comprehensive database
        return array(
            'akismet' => array(
                array(
                    'id' => 'akismet-xss-2019',
                    'title' => 'Cross-Site Scripting (XSS) vulnerability',
                    'severity' => 'Medium',
                    'type' => 'XSS',
                    'fixed_in' => '4.1.3',
                    'published_date' => '2019-07-15',
                    'references' => array('https://wpvulndb.com/vulnerabilities/9573')
                )
            ),
            'contact-form-7' => array(
                array(
                    'id' => 'cf7-file-upload-2020',
                    'title' => 'Unrestricted File Upload vulnerability',
                    'severity' => 'High',
                    'type' => 'File Upload',
                    'fixed_in' => '5.2.2',
                    'published_date' => '2020-08-12',
                    'references' => array('https://wpvulndb.com/vulnerabilities/10348')
                )
            )
        );
    }

    /**
     * Store vulnerability scan results
     */
    private function store_vulnerability_results($results) {
        update_option('wsa_pro_last_vulnerability_scan', $results);
        update_option('wsa_pro_last_vulnerability_scan_time', current_time('mysql'));

        // Also store in scan history
        global $wpdb;
        $table_name = $wpdb->prefix . 'wsa_scan_history';
        
        $wpdb->insert(
            $table_name,
            array(
                'scan_type' => 'vulnerability_pro',
                'scan_data' => json_encode($results),
                'created_at' => current_time('mysql')
            ),
            array('%s', '%s', '%s')
        );
    }

    /**
     * Add vulnerability data to plugin scan results
     */
    public function add_vulnerability_data($scan_results, $plugin_data) {
        if (!wsa_pro_is_license_active()) {
            return $scan_results;
        }

        $plugin_slug = dirname($plugin_data['plugin_path']);
        $vulnerabilities = $this->get_plugin_vulnerabilities($plugin_slug, $plugin_data['Version']);

        if (!empty($vulnerabilities)) {
            $scan_results['vulnerabilities'] = $vulnerabilities;
            $scan_results['vulnerability_count'] = count($vulnerabilities);
            $scan_results['highest_severity'] = $this->get_highest_severity($vulnerabilities);
        }

        return $scan_results;
    }

    /**
     * AJAX handler for vulnerability scan
     */
    public function ajax_vulnerability_scan() {
        check_ajax_referer('wsa_pro_nonce', 'nonce');
        
        if (!current_user_can('manage_options')) {
            wp_send_json_error(__('Insufficient permissions', 'wp-site-advisory-pro'));
        }

        if (!wsa_pro_is_license_active()) {
            wp_send_json_error(array(
                'message' => __('Vulnerability scanning requires a valid Pro license.', 'wp-site-advisory-pro'),
                'license_required' => true
            ));
        }

        $results = $this->scan();

        if (is_wp_error($results)) {
            wp_send_json_error($results->get_error_message());
        }

        wp_send_json_success($results);
    }
}